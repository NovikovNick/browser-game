[{"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/index.js":"1","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/App.js":"2","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/Board.js":"3","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/reducers/index.js":"4","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/ActionTypes.js":"5","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/ReduxActions.js":"6","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/WebSocket.js":"7","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/reducers/players.js":"8","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/Controls.js":"9","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/service.js":"10","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/config.js":"11","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/component/Polygon.js":"12","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/component/Point.js":"13","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/ShapeService.js":"14","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/GeometryService.js":"15"},{"size":198,"mtime":1609956792533,"results":"16","hashOfConfig":"17"},{"size":12331,"mtime":1614444517805,"results":"18","hashOfConfig":"17"},{"size":6326,"mtime":1614453863629,"results":"19","hashOfConfig":"17"},{"size":45,"mtime":1609929310065,"results":"20","hashOfConfig":"17"},{"size":206,"mtime":1610019869300,"results":"21","hashOfConfig":"17"},{"size":830,"mtime":1610568391498,"results":"22","hashOfConfig":"17"},{"size":4071,"mtime":1613243742026,"results":"23","hashOfConfig":"17"},{"size":1962,"mtime":1612555208835,"results":"24","hashOfConfig":"17"},{"size":2434,"mtime":1610221866980,"results":"25","hashOfConfig":"17"},{"size":1885,"mtime":1610010644983,"results":"26","hashOfConfig":"17"},{"size":85,"mtime":1609963658799,"results":"27","hashOfConfig":"17"},{"size":276,"mtime":1611392810658,"results":"28","hashOfConfig":"17"},{"size":217,"mtime":1611001125615,"results":"29","hashOfConfig":"17"},{"size":466,"mtime":1611316182124,"results":"30","hashOfConfig":"17"},{"size":334,"mtime":1611394057702,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"1lgwz23",{"filePath":"35","messages":"36","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"34"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"34"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"34"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/index.js",[],["67","68"],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/App.js",["69","70","71","72","73"],"import React from 'react';\nimport {applyMiddleware, combineReducers, createStore} from 'redux';\nimport {Provider} from 'react-redux';\nimport thunk from 'redux-thunk';\n\nimport * as reducers from './store/reducers';\n// Importing Sass with Bootstrap CSS\nimport './App.scss';\n\nimport Board from \"./container/Board\";\nimport WebSocket from \"./container/WebSocket\";\nimport * as actions from \"./store/ReduxActions\";\nimport {Container} from \"react-bootstrap\";\nimport Controls from \"./container/Controls\";\nimport * as ShapeService from \"./service/ShapeService\";\nimport * as GeometryService from \"./service/GeometryService\";\n\n\nconst store = createStore(combineReducers(reducers), applyMiddleware(thunk));\n// window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n\nfunction interpolateNumbers(p1, p2, mod) {\n    return p1 + (p2 - p1) * mod;\n}\n\nfunction interpolatePoints(p1, p2, mod) {\n    return [\n        interpolateNumbers(p1[0], p2[0], mod),\n        interpolateNumbers(p1[1], p2[1], mod)\n    ];\n}\n\nfunction interpolateGameObject(p1, p2, mod) {\n\n    return {\n        id: p1.id,\n        pos: interpolatePoints(p1.pos, p2.pos, mod),\n        rot: interpolateNumbers(p1.rot, p2.rot, mod),\n        shape: p1.shape\n    };\n}\n\nfunction interpolatePlayer(p1, p2, mod) {\n\n    const character = {\n        ...p1,\n        gameObject: interpolateGameObject(p2.obj, p1.obj, mod)\n    };\n    return character;\n}\n\nfunction equals(p1, p2) {\n    return p1[0] == p2[0] && p1[1] == p2[1];\n}\n\nfunction toGameObject(item, origin, offset, shape) {\n\n    const pos = [origin[0] - offset[0], origin[1] - offset[1]];\n    return {\n        origin: origin,\n        id: item.id,\n        pos: pos,\n        rot: item.rot,\n        shape: shape.map(p => {\n            return GeometryService.rotate([p[0] + pos[0], p[1] + pos[1]], item.rot, pos);\n        })\n    };\n}\n\nconst frameRate = 15 // 1000 / 60;\nlet timerId = setTimeout(function tick() {\n\n    const center = [window.innerWidth / 2, window.innerHeight / 2]\n    const state = store.getState().state;\n    const snapshots = state.snapshots;\n    const walls = state.walls;\n    const enemies = state.enemies;\n\n    if (snapshots) {\n        const fst = snapshots[0]\n        const snd = snapshots[1]\n\n        if(fst && snd) {\n\n            const frame = fst.timestamp - snd.timestamp;\n            const now = new Date().getTime();\n            const delay = now - fst.timestamp;\n            const mod = frame < delay ? 1 : delay / frame;\n\n            let projectiles = [];\n            let explosions = [];\n\n            // character\n            const character = interpolatePlayer(fst.character, snd.character, mod);\n            const offset = [\n                character.gameObject.pos[0] - center[0],\n                character.gameObject.pos[1] - center[1]\n            ];\n\n            if (character) {\n                character.gameObject.pos = center;\n                character.gameObject.shape = ShapeService.getPlayerShape().map(p => {\n                    return GeometryService.rotate(\n                        [p[0] + center[0], p[1] + center[1]],\n                        character.gameObject.rot,\n                        center\n                    );\n                });\n            }\n\n            // wall\n            const wallGroupedById = {};\n            const enemiesGroupedById = {};\n\n            for (const item of walls) {\n                wallGroupedById[item.id] = toGameObject(item, item.origin, offset, ShapeService.getWallShape());\n            }\n\n            for (const item of enemies) {\n                enemiesGroupedById[item.id] = toGameObject(item, item.origin, offset, ShapeService.getPlayerShape());\n            }\n\n            for (let i = snapshots.length - 1; i >=0 ; i--)  {\n\n                const snapshot = snapshots[i];\n                for (const item of snapshot.walls) {\n\n                    const id = item.id;\n\n                    if(!(id in wallGroupedById)) {\n                        wallGroupedById[id] = toGameObject(item, item.pos, offset, ShapeService.getWallShape());\n                    }\n                }\n\n\n                for (const item of snapshot.enemies) {\n\n                    const obj = item.obj;\n                    const id = obj.id;\n\n                    if(!(id in enemiesGroupedById)) {\n\n                        enemiesGroupedById[id] = toGameObject(obj, obj.pos, offset, ShapeService.getPlayerShape());\n\n                    } else if(!equals(enemiesGroupedById[id].origin, obj.pos) ) {\n\n                        enemiesGroupedById[id] = toGameObject(\n                            interpolateGameObject(enemiesGroupedById[id], obj, mod),\n                            obj.pos,\n                            offset,\n                            ShapeService.getPlayerShape());\n                    }\n                }\n            }\n\n            for (let i = snapshots.length - 1; i >=0 ; i--) {\n                const snapshot = snapshots[i];\n                for(const removed of snapshot.removed) {\n                    delete wallGroupedById[removed];\n                    delete enemiesGroupedById[removed];\n                }\n            }\n\n            const updatedWalls = [];\n            for (const [id, item] of Object.entries(wallGroupedById)) {\n                updatedWalls.push(item);\n            }\n\n            const updatedEnemies = [];\n            for (const [id, item] of Object.entries(enemiesGroupedById)) {\n                updatedEnemies.push(item);\n            }\n\n\n            store.dispatch(actions.updateState(character, updatedEnemies, projectiles, explosions, updatedWalls));\n        }\n\n\n        /*if(fst && snd) {\n            const frame = fst.timestamp - snd.timestamp;\n            const now = new Date().getTime();\n            const delay = now - fst.timestamp;\n            const mod = frame < delay ? 1 : delay / frame;\n            const offset = [\n                0,\n                0\n            ];\n\n            for (let i = 0; i < snapshots.length; i++)  {\n\n                const wallObjIds = new Set();\n\n                walls.forEach(w => wallObjIds.add(w.id));\n                fst.walls.length > 0 && fst.walls.forEach(w => wallObjIds.add(w.id))\n                snd.walls.length > 0 && snd.walls.forEach(w => wallObjIds.add(w.id))\n\n                const wallGroupedById = walls.reduce((r, a) => {r[a.id] = a;return r;}, {});\n                const fstGroupedById = fst.walls.reduce((r, a) => {r[a.id] = a;return r;}, {});\n                const sndGroupedById = snd.walls.reduce((r, a) => {r[a.id] = a;return r;}, {});\n\n                wallObjIds.forEach(id => {\n\n                    const isExist = wallGroupedById[id] != undefined;\n                    const isUpdated = fstGroupedById[id] != undefined && sndGroupedById[id] != undefined;\n                    const isCreated = fstGroupedById[id] != undefined && wallGroupedById[id] == undefined;\n                    const isRemoved = fst.removed && fst.removed.includes(id);\n\n                    if(!isRemoved && (isExist || isUpdated || isCreated)) {\n\n                        const wall = isUpdated\n                            ? interpolateGameObject(sndGroupedById[id], fstGroupedById[id], mod)\n                            : isCreated ? fstGroupedById[id] : wallGroupedById[id];\n\n                        const wallOffset = [wall.pos[0] - offset[0], wall.pos[1] - offset[1]];\n\n                        updatedWalls.push({\n                            id: id,\n                            pos: wall.pos,\n                            rot: wall.rot,\n                            shape: ShapeService.getWallShape().map(p => {\n                                return GeometryService.rotate([p[0] + wallOffset[0], p[1] + wallOffset[1]], wall.rot, wallOffset);\n                            })\n                        })\n                    }\n                })\n            }\n        }*/\n\n        /*if (fst && snd && fst.character && snd.character) {\n\n            const frame = fst.timestamp - snd.timestamp;\n            const now = new Date().getTime();\n            const delay = now - fst.timestamp;\n            const mod = frame < delay ? 1 : delay / frame;\n\n            // player\n            character = interpolatePlayer(fst.character, snd.character, mod);\n            const offset = [\n                character.gameObject.pos[0] - center[0],\n                character.gameObject.pos[1] - center[1]\n            ];\n            if (character) {\n                character.gameObject.pos = center;\n                character.gameObject.shape = ShapeService.getPlayerShape().map(p => {\n                    return GeometryService.rotate(\n                        [p[0] + center[0], p[1] + center[1]],\n                        character.gameObject.rot,\n                        center\n                    );\n                });\n            }\n\n            // enemies\n            {\n                const fstGroupedById = fst.enemies.reduce((r, a) => {\n                    r[a.obj.id] = a;\n                    return r;\n                }, {});\n\n                const sndGroupedById = snd.enemies.reduce((r, a) => {\n                    r[a.obj.id] = a;\n                    return r;\n                }, {});\n\n                for (const [id, value] of Object.entries(fstGroupedById)) {\n                    if (sndGroupedById[id]) {\n                        const p1 = value\n                        const p2 = sndGroupedById[id]\n                        const item = interpolatePlayer(p1, p2, mod);\n\n                        const pos = [item.gameObject.pos[0] - offset[0], item.gameObject.pos[1] - offset[1]];\n                        item.gameObject.pos = pos;\n                        item.gameObject.shape = ShapeService.getPlayerShape().map(p => {\n                            return GeometryService.rotate(\n                                [p[0] + pos[0], p[1] + pos[1]],\n                                item.gameObject.rot,\n                                pos\n                            );\n                        });\n\n                        enemies.push(item);\n                    }\n                }\n            }\n\n            // projectiles\n            {\n                const fstGroupedById = fst.projectiles.reduce((r, a) => {\n                    r[a.id] = a;\n                    return r;\n                }, {});\n                const sndGroupedById = snd.projectiles.reduce((r, a) => {\n                    r[a.id] = a;\n                    return r;\n                }, {});\n\n                for (const [id, value] of Object.entries(fstGroupedById)) {\n                    if (sndGroupedById[id]) {\n                        const p1 = value\n                        const p2 = sndGroupedById[id]\n\n                        const item = interpolateGameObject(p2, p1, mod);\n\n                        const pos = [item.pos[0] - offset[0], item.pos[1] - offset[1]];\n                        item.pos = pos;\n                        item.shape = ShapeService.getBulletShape().map(p => {\n                            return GeometryService.rotate(\n                                [p[0] + pos[0], p[1] + pos[1]],\n                                item.rot,\n                                pos\n                            );\n                        });\n\n                        projectiles.push(item);\n                    }\n                }\n            }\n\n            // explosions\n            {\n                Array.isArray(fst.explosions) && fst.explosions.map(item => {\n\n                    const pos = [item.pos[0] - offset[0], item.pos[1] - offset[1]];\n                    explosions.push({timestamp: now, point: pos})\n                })\n            }\n        }*/\n        //store.dispatch(actions.updateState(character, enemies, projectiles, explosions, updatedWalls));\n    }\n\n    timerId = setTimeout(tick, frameRate);\n}, frameRate);\n\nfunction App() {\n    return (\n        <Provider store={store}>\n\n            <WebSocket host={\"http://192.168.0.103:8080\"}/>\n            <Board/>\n\n            <Container className=\"p-3\">\n                <div className=\"row\">\n                    <nav className=\"offset-md-10 col-md-2 d-none d-md-block bg-light sidebar\">\n                        <Controls/>\n                    </nav>\n\n                    <main role=\"main\" className=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"></main>\n\n                </div>\n            </Container>\n        </Provider>\n    );\n}\n\nexport default App;\n","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/Board.js",["74","75","76","77","78","79"],"import React, {useEffect, useRef} from 'react';\nimport {connect} from 'react-redux';\nimport {bindActionCreators} from 'redux';\n\nimport * as Store from \"../store/ReduxActions\";\n\nfunction Grid({width, height, n}) {\n    const grid = [];\n    for (var i = 1; i < n; i++) {\n\n        const y = (height / n) * i;\n        const x = (width / n) * i;\n        const color = i % 2 != 0 ? \"#eee\" : \"#888\";\n\n        grid.push(<line key={\"v\" + i} x1=\"0\" y1={y} x2={width}  y2={y}      stroke={color}/>);\n        grid.push(<line key={\"h\" + i} x1={x} y1=\"0\" x2={x}      y2={height} stroke={color}/>);\n    }\n    return grid;\n}\n\nfunction random() {\n    const min = Math.ceil(0);\n    const max = Math.floor(800);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nconst p1 = [random(), random()]\nconst p2 = [random(), random()]\nconst p3 = [random(), random()]\nconst p4 = [random(), random()]\n\nfunction Line({p1, p2, color}) {\n    return <g>\n        <line stroke={color}\n              x1={p1[0]} x2={p2[0]}\n              y1={p1[1]} y2={p2[1]}/>\n        <circle cx={p1[0]} cy={p1[1]} r={5} fill={color}/>\n        <circle cx={p2[0]} cy={p2[1]} r={5} fill={color}/>\n    </g>;\n}\n\n/**\n * determinant for matrix [\n *   [a, c],\n *   [b, d]\n * ]\n * @param matrix [2][2]\n * @returns {number}\n */\nfunction det(matrix) {\n    const a = matrix[0][0], b = matrix[1][0], c = matrix[0][1], d = matrix[1][1];\n    return a * d - b * c;\n}\n\nfunction intersect(p1, p2, p3, p4) {\n\n    const x1 = p1[0], x2 = p2[0], x3 = p3[0], x4 = p4[0];\n    const y1 = p1[1], y2 = p2[1], y3 = p3[1], y4 = p4[1];\n\n    const uNumerator = det([\n        [x4 - x2, x4 - x3],\n        [y4 - y2, y4 - y3]\n    ])\n    const vNumerator = det([\n        [x1 - x2, x4 - x2],\n        [y1 - y2, y4 - y2]\n    ]);\n    const denominator = det([\n        [x1 - x2, x4 - x3],\n        [y1 - y2, y4 - y3]\n    ]);\n    const u = uNumerator / denominator;\n    const v = vNumerator / denominator;\n    return {\n        intersect: u > 0 && u < 1 && v > 0 && v < 1,\n        point: [u * (x1 - x2) + x2, u * (y1 - y2) + y2]\n    };\n}\nconst intersected = intersect(p1, p2, p3, p4);\n// console.log(p1, p2, p3, p4, intersected)\n\nlet sequence = 0;\nlet frame = 0;\n\nconst environment = {\n    ground: new Image(),\n    isLoading: true\n}\nenvironment.ground.src = \"/images/environment.png\";\nenvironment.ground.onload = () => {\n    environment.isLoading = false;\n}\n\nconst animation = {\n    characterWalkLeft : {\n        sprites: new Image(),\n        frameWidth: 108,\n        frameHeight: 140,\n        coords: [\n            [0, 0],\n            [108, 0],\n            [108*2, 0],\n            [108*3, 0],\n            [108*4, 0],\n            [108*5, 0],\n            [108*6, 0],\n            [108*7, 0]\n        ],\n        isLoading: true\n    }\n};\nanimation.characterWalkLeft.sprites.src = \"/images/sprite.png\";\nanimation.characterWalkLeft.sprites.onload = () => {\n    animation.characterWalkLeft.isLoading = false;\n}\n\nfunction isLoading () {\n    return environment.isLoading && animation.characterWalkLeft.isLoading;\n};\n\nfunction Board({character, enemies, projectiles, explosions, walls}) {\n\n    const canvas = useRef(null);\n\n    useEffect(() => {\n\n        const ctx = canvas.current.getContext('2d');\n        ctx.font = \"24px serif\";\n\n        sequence++;\n        frame = sequence % 60;\n\n        ctx.fillStyle = 'black';\n        ctx.fillRect(0, 0, 2000, 1000)\n\n        console.log(frame + \" - \" + Math.ceil(frame / 9))\n\n        ctx.fillStyle = 'white';\n        ctx.fillText(\"Frame number: \" + frame, 10, 30);\n        ctx.fillText(\"Ping: \" + 0, 10, 60);\n\n        if(isLoading()) {\n            ctx.fillText(\"connecting...\", 10, 60);\n        } else {\n\n            const coord = animation.characterWalkLeft.coords[Math.ceil(frame / 9)]\n\n            { // player\n                const pos = character.gameObject.pos;\n                ctx.fillStyle = '#e6f7ff';\n                ctx.fillRect(pos[0]-400, pos[1]-400, 800, 800);\n\n                for (let i = 0; i < character.gameObject.shape.length; i++) {\n                    const p = character.gameObject.shape[i];\n\n                    ctx.drawImage(\n                        animation.characterWalkLeft.sprites,\n                        coord[0], coord[1],\n                        108, 140,\n                        pos[0] - 108/2, pos[1] - 140/2, 108, 140\n                    );\n                    ctx.fillStyle = 'blue';\n                    ctx.fillRect(p[0], p[1], 5, 5);\n                }\n            }\n\n            {// enemies\n                for (let i = 0; i < enemies.length; i++) {\n                    const enemy = enemies[i];\n                    const pos = enemy.pos;\n\n                    for (let j = 0; j < enemy.shape.length; j++) {\n                        const p = enemy.shape[j];\n\n                        ctx.drawImage(\n                            animation.characterWalkLeft.sprites,\n                            coord[0], coord[1],\n                            108, 140,\n                            pos[0] - 108/2, pos[1] - 140/2, 108, 140\n                        );\n                        ctx.fillStyle = 'blue';\n                        ctx.fillRect(p[0], p[1], 5, 5);\n                    }\n                }\n            }\n\n            {// wall\n                for (let i = 0; i < walls.length; i++) {\n                    const pos = walls[i].pos;\n                    const wall = walls[i].shape;\n\n                    ctx.drawImage(\n                        environment.ground,\n                        184, 102,\n                        76, 76,\n                        pos[0] - 50, pos[1] - 50, 100, 102\n                    );\n\n                    for (let j = 0; j < wall.length; j++) {\n                        const p = wall[j];\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(p[0], p[1], 5, 5);\n                    }\n                }\n            }\n        }\n    });\n\n    return ( <canvas ref={canvas} width={2000} height={1000}/>);\n}\n\nconst mapStateToProps = state => ({\n    character: state.state.character,\n    enemies: state.state.enemies,\n    projectiles: state.state.projectiles,\n    explosions: state.state.explosions,\n    walls: state.state.walls\n});\nconst mapDispatchToProps = dispatch => ({\n    actions: bindActionCreators(Store, dispatch)\n});\nexport default connect(mapStateToProps, mapDispatchToProps)(Board);\n","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/reducers/index.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/ActionTypes.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/ReduxActions.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/WebSocket.js",["80","81","82","83","84","85"],"import {Client} from \"@stomp/stompjs\";\nimport * as SockJS from 'sockjs-client';\n\nimport React, {useEffect} from 'react';\nimport {connect} from 'react-redux';\nimport {bindActionCreators} from 'redux';\n\nimport * as Store from \"../store/ReduxActions\";\n\nconst inputState = {\n    ackSN: [],\n    leftBtnClicked: false,\n    rightBtnClicked: false,\n    rotationAngleRadian: 0,\n    isPressedW: false,\n    isPressedA: false,\n    isPressedS: false,\n    isPressedD: false\n}\n\nfunction onKeyPress(e) {\n    switch (e.keyCode) {\n        case 119:\n            inputState.isPressedW = true;\n            break;\n        case 97:\n            inputState.isPressedA = true;\n            break;\n        case 100:\n            inputState.isPressedD = true;\n            break;\n        case 115:\n            inputState.isPressedS = true;\n            break;\n    }\n};\n\nfunction onKeyUp(e) {\n\n    switch (e.keyCode) {\n        case 87:\n            inputState.isPressedW = false;\n            break;\n        case 65:\n            inputState.isPressedA = false;\n            break;\n        case 68:\n            inputState.isPressedD = false;\n            break;\n        case 83:\n            inputState.isPressedS = false;\n            break;\n    }\n};\n\ninputState.leftBtnClicked =  inputState.rightBtnClicked = false;\n\n\nfunction onMouseUpdate(e) {\n\n    switch (e.which) {\n        case 1:\n            inputState.leftBtnClicked = true;\n            break;\n        case 3:\n            inputState.rightBtnClicked = true;\n            break;\n    }\n\n    inputState.rotationAngleRadian = Math.atan2(window.innerHeight / 2 - e.pageY, window.innerWidth / 2 - e.pageX);\n}\n\nconst ENDPOINT = {\n    APP_NAME: \"/game\",\n    TOPIC_PLAYER_LIST: \"/secured/user/queue/specific-user-user\",\n    TOPIC_PLAYER_UPDATE: '/frontend/update'\n};\n\nconst webSocket = new Client();\n\nfunction WebSocket({host, actions}) {\n\n    useEffect(() => {\n        webSocket.configure({\n            webSocketFactory: () => new SockJS(host + ENDPOINT.APP_NAME),\n            onConnect: (frame) => {\n\n                var url = webSocket.webSocket._transport.url;\n                url = url.split(\"/\");\n                var sessionId = url[url.length - 2];\n                webSocket.sessionId = sessionId;\n\n                actions.updateSessionId(sessionId)\n                actions.changePlayerName({sessionId: sessionId})\n\n                webSocket.subscribe(ENDPOINT.TOPIC_PLAYER_LIST + sessionId, message => {\n                    const serverSnapshot = JSON.parse(message.body);\n                    inputState.ackSN = [serverSnapshot.sn].concat(inputState.ackSN.slice(0, 10))\n                    actions.addSnapshot(serverSnapshot);\n                });\n\n                let timerId = setTimeout(function tick() {\n\n                    webSocket.publish({\n                        destination: ENDPOINT.TOPIC_PLAYER_UPDATE,\n                        body: JSON.stringify(inputState)\n                    });\n\n                    timerId = setTimeout(tick, 40); // (*)\n                }, 40);\n            },\n            onWebSocketError: e => console.error(\"Chat service is unavailable\", e),\n            // debug: str => console.log(new Date(), str)\n        });\n        webSocket.activate();\n\n        document.addEventListener('mousedown', onMouseUpdate, false);\n        document.addEventListener('mousemove', onMouseUpdate, false);\n        document.addEventListener('mouseenter', onMouseUpdate, false);\n        document.addEventListener('mousedown', e => {\n            if (e.which == 1) inputState.leftBtnClicked = true;\n            if (e.which == 3) inputState.rightBtnClicked = true;\n        });\n        document.addEventListener('mouseup', e => {\n            inputState.leftBtnClicked = inputState.rightBtnClicked = false;\n        });\n\n\n        document.addEventListener('keypress', onKeyPress, false);\n        document.addEventListener('keyup', onKeyUp, false);\n    })\n\n    return (\n        <div/>\n    );\n}\n\nconst mapDispatchToProps = dispatch => ({\n    actions: bindActionCreators(Store, dispatch)\n});\nexport default connect(null, mapDispatchToProps)(WebSocket);\n","/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/store/reducers/players.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/container/Controls.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/service.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/config.js",[],["86","87"],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/component/Polygon.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/component/Point.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/ShapeService.js",[],"/home/nicknovikov/WORKSPACE/small-test-server/frontend/src/service/GeometryService.js",[],{"ruleId":"88","replacedBy":"89"},{"ruleId":"90","replacedBy":"91"},{"ruleId":"92","severity":1,"message":"93","line":53,"column":18,"nodeType":"94","messageId":"95","endLine":53,"endColumn":20},{"ruleId":"92","severity":1,"message":"93","line":53,"column":36,"nodeType":"94","messageId":"95","endLine":53,"endColumn":38},{"ruleId":"96","severity":1,"message":"97","line":165,"column":25,"nodeType":"98","messageId":"99","endLine":165,"endColumn":27},{"ruleId":"96","severity":1,"message":"97","line":170,"column":25,"nodeType":"98","messageId":"99","endLine":170,"endColumn":27},{"ruleId":"96","severity":1,"message":"100","line":331,"column":5,"nodeType":"98","messageId":"99","endLine":331,"endColumn":12},{"ruleId":"96","severity":1,"message":"101","line":7,"column":10,"nodeType":"98","messageId":"99","endLine":7,"endColumn":14},{"ruleId":"92","severity":1,"message":"102","line":13,"column":29,"nodeType":"94","messageId":"95","endLine":13,"endColumn":31},{"ruleId":"96","severity":1,"message":"103","line":31,"column":10,"nodeType":"98","messageId":"99","endLine":31,"endColumn":14},{"ruleId":"96","severity":1,"message":"104","line":78,"column":7,"nodeType":"98","messageId":"99","endLine":78,"endColumn":18},{"ruleId":"105","severity":1,"message":"106","line":166,"column":13,"nodeType":"107","messageId":"108","endLine":184,"endColumn":14},{"ruleId":"105","severity":1,"message":"106","line":186,"column":13,"nodeType":"107","messageId":"108","endLine":204,"endColumn":14},{"ruleId":"109","severity":1,"message":"110","line":22,"column":5,"nodeType":"111","messageId":"112","endLine":35,"endColumn":6},{"ruleId":"109","severity":1,"message":"110","line":40,"column":5,"nodeType":"111","messageId":"112","endLine":53,"endColumn":6},{"ruleId":"109","severity":1,"message":"110","line":61,"column":5,"nodeType":"111","messageId":"112","endLine":68,"endColumn":6},{"ruleId":"96","severity":1,"message":"100","line":109,"column":21,"nodeType":"98","messageId":"99","endLine":109,"endColumn":28},{"ruleId":"92","severity":1,"message":"93","line":121,"column":25,"nodeType":"94","messageId":"95","endLine":121,"endColumn":27},{"ruleId":"92","severity":1,"message":"93","line":122,"column":25,"nodeType":"94","messageId":"95","endLine":122,"endColumn":27},{"ruleId":"88","replacedBy":"113"},{"ruleId":"90","replacedBy":"114"},"no-native-reassign",["115"],"no-negated-in-lhs",["116"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'id' is assigned a value but never used.","Identifier","unusedVar","'timerId' is assigned a value but never used.","'Grid' is defined but never used.","Expected '!==' and instead saw '!='.","'Line' is defined but never used.","'intersected' is assigned a value but never used.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",["115"],["116"],"no-global-assign","no-unsafe-negation"]